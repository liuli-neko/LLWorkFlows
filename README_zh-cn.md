# LLWorkFlows
一次对流计算框架的尝试 

## 为什么要做这个
简化程序或项目的构建一直是一个挑战，许多大佬已经使用他们的框架来提供各种答案。例如： 

著名的UI框架，如 Qt、Flutter、Node.Js 等。还有广泛使用的Chromium核心，它们都具有不错的性能和无与伦比的便利性。
著名的游戏框架，如Godot Engine、Unreal Engine、unity engine等，比简单的UI框架有更好的性能和更强的动画支持，但它们也更大。而且学习成本更高。
但是现在，我只需要一个用C++开发的流处理框架来使用越来越强大的CPU和GPU，而无需细致的分析和考虑不同线程的同步。

## 我想要实现什么
我想要实现一个流计算框架，它应当具备如下的特点：
- 函数式可自定义节点。
- 可自行同步的安全的数据传递。
- 细致的状态转移与控制。
- 完备的调试接口。
- 充分的利用现有资源进行并行计算。
- 完全插件化的功能管理。
- 面向接口编程，更少的实现。

基于以上特点，这可能更偏向一种编程指导，通过提供接口与运行流程的约束规范程序的结构。使其更容易优化与测试。
## 一个程序应该如何运行
```mermaid
---
title: 一个像"hello world!"一样的简单程序
---
flowchart LR
    start(开始) --进入函数--> act1[/"输出hello world!"/] 
    act1--退出函数--> enda(结束)
```

可以让这个程序更加的复杂一点。

```mermaid
---
title: 一个稍微复杂一点的程序示例
---
flowchart LR
    start(开始) --进入函数--> act1["活动1"]
    act1--下一步--> act2["活动2"]
    act2--下一不--> act3["活动3"]
    act2--下一不--> act4["活动4"]
    act3--下一步-->act5["活动5"]
    act4--下一步-->act5
    act5--退出函数-->enda(结束)
```

是不是觉得还是少了什么，这里没有条件结构和循环结构呢，为什么没有呢，因为这两个结构会极大的增加图本身的复杂性。如何保证只有顺序结构的图能够安全效率的运行本身就已经足够复杂了。当然，如果你可以自行扩展对其他结构的支持。

接下来是对以上结构的细化讨论了。首先需要明确的是，我们期望所有的活动或者说流程中的每一步都是一个节点，即特点中的函数式节点。在这里节点可能需要一下的行为：

- 能够被方便的调试。
- 拥有独立的状态且能够安全的在各个状态之间转移。
- 能够接收来自上一步的数据。
- 能够提供数据给下一步执行。
- 能够取得想要的值。
